def rootfs_runtime_mapping(d):
    pn = d.getVar('PN', True)
    runtime_mapping_rename("PACKAGE_INSTALL", pn, d)
    runtime_mapping_rename("PACKAGE_INSTALL_ATTEMPTONLY", pn, d)
    runtime_mapping_rename("BAD_RECOMMENDATIONS", pn, d)

rootfs_runtime_mapping(d)

def runtime_mapping_rename (varname, pkg, d):
    #bb.note("%s before: %s" % (varname, d.getVar(varname, True)))

    if bb.data.inherits_class('packagegroup', d):
        return

    new_depends = {}
    deps = bb.utils.explode_dep_versions2(d.getVar(varname, True) or "")
    for depend in deps:
        new_depend = get_package_mapping(depend, pkg, d)
        new_depends[new_depend] = deps[depend]

    d.setVar(varname, bb.utils.join_deps(new_depends, commasep=False))

    #bb.note("%s after: %s" % (varname, d.getVar(varname, True)))

def get_package_mapping (pkg, basepkg, d):
    import oe.packagedata

    data = oe.packagedata.read_subpkgdata(pkg, d)
    key = "PKG_%s" % pkg

    if key in data:
        # Have to avoid undoing the write_extra_pkgs(global_variants...)
        if bb.data.inherits_class('allarch', d) and data[key] == basepkg:
            return pkg
        return data[key]

    return pkg

